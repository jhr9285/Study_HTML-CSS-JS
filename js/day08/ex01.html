<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>test</title>
<link rel="stylesheet" type="text/css" href="../css/w3.css">
<link rel="stylesheet" type="text/css" href="../css/chopa.css">
<script type="text/javascript">

	var param = '?id=chopa&pw=12345&mail=chopa@githrd.com&job=doctor';
	/* param 의 데이터를 분리해서 연관배열을 만드시오. (반복문)
	   (& 앞에 있는 것들을 파라미터라고 부름.) 
	   
	   그리고 아래와 같이 출력하시오.
	   
	   ex)
	   		id : chopa
	   		pw : 12345
	   		mail : chopa@githrd.com
	   		job : docter
	   		
	   
	   참고 함수)
	   		substring(시작인덱스, 끝인덱스)
	   		==> 문자열의 시작인덱스에서부터 끝인덱스 이전까지 잘라서 반환해주는 함수
	   		
	   		substring(시작인덱스)
	   		==> 문자열의 시작인덱스에서부터 마지막까지 잘라서 반환해주는 함수
	   */
	
	// 문자열도 배열이다. 
	
//	var data = param.substring(1);
	/* alert(data);  */// 위 인덱스의 값을 잘라낸 원본

/*  var idx1 = param.indexOf('&');
	document.write(idx1);
  	var idx2 = param.indexOf('&', idx1 + 1);
	document.write(idx2);
 	var idx3 = param.indexOf('&', idx2 + 1);
	document.write(idx3); */
	
/*	var arr = [];
	var tmp = data; // 위 인덱스의 값을 잘라낸 원본
	for(var i = 0; ; i++){
		var idx = tmp.indexOf('&'); // 문자열의 첫 번째 & 만 찾을 수 있는 상태. indexOf는 인덱스를 반환하는 메소드.
		if(idx == -1){ // idx는 인덱스값을 담는 변수인데, 마지막까지 다 substring으로 잘라내면 남는 데이터가 없다. -1은 찾는 문자가 없을 때 뜨는 indexOf의 반환값.
			arr[i] = tmp;
			break;
		}
		var str = tmp.substring(0, idx); // 0부터 & 앞까지 잘라서 반환
		arr[i] = str;
		tmp = tmp.substring(idx + 1); // substring 이용해서 & 다음 위치부터 마지막까지 잘라낸다
	}
	
	
	// 연관배열 만들기
	
	var keys = []; // 키값만 따로 모아놓는 배열
	var arr2 = []; // 데이터만 따로 모아놓는 배열
	var tmp2 = data;
	for(j = 0; j < arr.length; j++){
		tmp2 = arr[j]; // arr의 원소인 문자열을 tmp2라는 변수에 담음
		var idx2 = tmp2.indexOf('='); // 문자열의 첫 번째 =를 찾음
 		var key = tmp2.substring(0, idx2); // 문자열의 = 앞부분을 key 변수에 담음
 		var value = tmp2.substring(idx2 + 1); // 문자열의 = 뒷부분을 value 변수에 담음
 		keys[j] = key;
 		arr2[j] = value;
	} 
	document.write(keys + '<br>');
	document.write(arr2 + '<br>');
*/	

	// split 함수로 다시 만들어보기
	param = param.substring(1);
	param = param.split('&');
	
	var data = {}; // 연관배열은 중괄호로 표기 (인덱스로 못 꺼내니까 타입은 배열이 아니라 객체임. 배열처럼 쓰긴 하지만 그건 키값 기준.)
	
	var keys = new Array(); // 키값 배열
	for(i = 0; i < param.length; i++){
		var arr = param[i];
		var tmp = arr.split('='); // = 기준으로 id와 abcde를 잘라냈고, 그걸 tmp에 담아둠. tmp는 split으로 자른 반환값이라 무조건 배열임.
		var key = tmp[0]; // key값 변수 key는 tmp 배열의 첫번째 데이터 = id
		var val = tmp[1]; // 데이터 변수 val은 tmp 배열의 두번째 데이터 = abced 
	/* 	keys.push(key); */  // keys 배열에 key값을 맨 뒤로 넣는다. [] -> [1(맨뒤)] -> [1, 2(맨뒤)] -> [1, 2, 3(맨뒤)]
		keys[i] = key; // key값 모아두는 배열 keys에 key값 변수를 대입
		data[key] = val; // 데이터 모아두는 배열 data에 데이터 변수를 대입
		// (data[key] 라고 작성함으로써 인덱스 대신 key라는 변수에 대입되는 문자를 인덱스처럼 사용하도록 형식이 적용됨)
		// 결과적으로 연관배열 data = {id:chopa ... } 로 만들어짐. 	
	}
	
 	for(var i = 0 ; i < keys.length; i++ ){
		document.write(keys[i] + ' - ' +data[keys[i]] + '<br>');
	}
 
	document.write(typeof data + '<br>');
	document.write(Array.isArray(data) + '<br>');
	
	
	
	
</script>
</head>
<body>

</body>
</html>